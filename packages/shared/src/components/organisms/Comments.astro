---
/**
 * Comments Component (Organism)
 *
 * Displays a lazy-loaded Giscus comment widget for blog posts.
 * The widget loads only when scrolled into view to preserve performance.
 *
 * Features:
 * - Lazy loading via Intersection Observer
 * - Theme adaptation (light/dark)
 * - Internationalization support
 * - Accessibility compliant
 * - Layout shift prevention
 *
 * @component
 */

import { useTranslations } from "@/i18n";
import { getGiscusLang } from "@/lib/comments-config";

interface Props {
	/** Current page slug for mapping to GitHub Discussion */
	slug: string;
	/** Current site locale (defaults to 'en') */
	locale?: string;
	/** Optional CSS class for container */
	class?: string;
}

const { slug, locale = "en", class: className = "" } = Astro.props;

// Get translations
const t = useTranslations(locale);

// Prepare Giscus configuration
const lang = getGiscusLang(locale);
---

<section
	class:list={['comments-section', className]}
	data-testid="comments-section"
	aria-labelledby="comments-heading"
>
	<h2 id="comments-heading" class="text-2xl font-bold mb-6 text-foreground">
		{t('comments.title')}
	</h2>

	<!-- Reserved space container to prevent CLS -->
	<div
		class="giscus-container min-h-50 relative"
		data-slug={slug}
		data-lang={lang}
		data-testid="giscus-container"
	>
		<!-- Loading state -->
		<div class="giscus-loading absolute inset-0 flex items-center justify-center text-foreground-muted">
			<span>{t('comments.loading')}</span>
		</div>
		
		<!-- Giscus script will be injected here by client-side JS -->
	</div>
</section>

<script>
	import { giscusConfig, getGiscusTheme } from '@/lib/comments-config';
	
	/**
	 * Detect current theme from document
	 */
	function getCurrentTheme(): string {
		const isDark = document.documentElement.classList.contains('dark');
		return getGiscusTheme(isDark);
	}
	
	/**
	 * Inject Giscus script into container
	 */
	function loadGiscusWidget(container: HTMLElement): void {
		const lang = container.dataset.lang || 'en';
		const theme = getCurrentTheme();
		
		// Remove loading indicator
		const loading = container.querySelector('.giscus-loading');
		if (loading) {
			loading.remove();
		}
		
		// Create Giscus script element
		const script = document.createElement('script');
		script.src = 'https://giscus.app/client.js';
		script.setAttribute('data-repo', giscusConfig.repo);
		script.setAttribute('data-repo-id', giscusConfig.repoId);
		script.setAttribute('data-category', giscusConfig.category);
		script.setAttribute('data-category-id', giscusConfig.categoryId);
		script.setAttribute('data-mapping', giscusConfig.mapping);
		script.setAttribute('data-strict', giscusConfig.strict ? '1' : '0');
		script.setAttribute('data-reactions-enabled', giscusConfig.reactionsEnabled ? '1' : '0');
		script.setAttribute('data-emit-metadata', giscusConfig.emitMetadata ? '1' : '0');
		script.setAttribute('data-input-position', giscusConfig.inputPosition);
		script.setAttribute('data-theme', theme);
		script.setAttribute('data-lang', lang);
		script.setAttribute('crossorigin', 'anonymous');
		script.async = true;
		
		container.appendChild(script);
	}
	
	/**
	 * Update Giscus theme via postMessage
	 */
	function updateGiscusTheme(newTheme: string): void {
		const iframe = document.querySelector<HTMLIFrameElement>('iframe.giscus-frame');
		if (iframe?.contentWindow) {
			iframe.contentWindow.postMessage(
				{ giscus: { setConfig: { theme: newTheme } } },
				'https://giscus.app'
			);
		}
	}
	
	/**
	 * Initialize lazy loading with Intersection Observer
	 */
	function initializeLazyLoading(): void {
		const container = document.querySelector<HTMLElement>('.giscus-container');
		if (!container) return;
		
		// Create observer to detect when comments section is visible
		const observer = new IntersectionObserver(
			(entries) => {
				entries.forEach((entry) => {
					if (entry.isIntersecting) {
						// Container is visible - load Giscus
						loadGiscusWidget(entry.target as HTMLElement);
						observer.unobserve(entry.target);
					}
				});
			},
			{
				// Load when 10% visible with 100px margin for smooth experience
				rootMargin: '100px',
				threshold: 0.1,
			}
		);
		
		observer.observe(container);
	}
	
	/**
	 * Listen for theme changes and update widget
	 */
	function setupThemeListener(): () => void {
		// Listen for custom theme change events
		const onThemeChanged = ((event: CustomEvent) => {
			const newTheme = event.detail?.theme || getCurrentTheme();
			updateGiscusTheme(newTheme);
		}) as EventListener;

		document.addEventListener('themeChanged', onThemeChanged);
		
		// Also listen for dark class changes via MutationObserver
		const observer = new MutationObserver(() => {
			const newTheme = getCurrentTheme();
			updateGiscusTheme(newTheme);
		});
		
		observer.observe(document.documentElement, {
			attributes: true,
			attributeFilter: ['class'],
		});

		return () => {
			document.removeEventListener('themeChanged', onThemeChanged);
			observer.disconnect();
		};
	}

	const CLEANUP_KEY = '__commentsWidgetCleanup';

	const cleanup = () => {
		const currentCleanup = window[CLEANUP_KEY];
		if (typeof currentCleanup === 'function') {
			currentCleanup();
			window[CLEANUP_KEY] = undefined;
		}
	};

	const initialize = () => {
		cleanup();
		initializeLazyLoading();
		const removeThemeListener = setupThemeListener();
		window[CLEANUP_KEY] = () => {
			removeThemeListener();
		};
	};

	document.addEventListener('astro:page-load', initialize);
	document.addEventListener('astro:before-preparation', cleanup);
	initialize();
</script>

<style>
	.comments-section {
		margin-top: 3rem;
		padding-top: 2rem;
		border-top: 1px solid var(--color-border);
	}
	
	.giscus-container {
		/* Reserved minimum height prevents CLS when widget loads */
		min-height: 200px;
		/* Smooth transition for loading */
		transition: min-height 0.3s ease;
	}
	
	.giscus-loading {
		animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
	}
	
	@keyframes pulse {
		0%, 100% {
			opacity: 1;
		}
		50% {
			opacity: 0.5;
		}
	}
	
	/* Ensure iframe is responsive */
	.giscus-container :global(iframe) {
		width: 100%;
		border: none;
	}
</style>
