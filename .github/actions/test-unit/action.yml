name: 'Unit Tests (Vitest)'
description: 'Run Vitest unit tests with coverage reporting'
author: 'yacosta738'

inputs:
  coverage:
    description: 'Enable coverage reporting'
    required: false
    default: 'true'
  project:
    description: 'Specific project to test (portfolio/api/all)'
    required: false
    default: 'all'
  upload-coverage:
    description: 'Upload coverage artifact'
    required: false
    default: 'true'

outputs:
  coverage-percentage:
    description: 'Code coverage percentage'
    value: ${{ steps.coverage-report.outputs.percentage }}
  tests-passed:
    description: 'Number of tests passed'
    value: ${{ steps.run-tests.outputs.passed }}

runs:
  using: "composite"
  steps:
    - name: Cache Vitest
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830
      with:
        path: |
          node_modules/.vitest
          apps/*/node_modules/.vitest
        key: ${{ runner.os }}-vitest-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-vitest-
    - name: Install dependencies
      shell: bash
      run: |
        if [ "${{ inputs.project }}" == "all" ]; then
          pnpm install --frozen-lockfile
          cd apps/portfolio && pnpm install --frozen-lockfile
          cd ../api && pnpm install --frozen-lockfile
        else
          cd apps/${{ inputs.project }}
          pnpm install --frozen-lockfile
        fi
    - name: Run unit tests
      id: run-tests
      shell: bash
      run: |
        echo "🧪 Running unit tests..."

        if [ "${{ inputs.project }}" == "all" ]; then
          echo "Testing all projects..."
          pnpm test:unit
          rc=$?
        else
          echo "Testing ${{ inputs.project }}..."
          cd apps/${{ inputs.project }}
          pnpm test:unit
          rc=$?
        fi

        # Expose whether tests passed and fail the step on non-zero exit code
        if [ $rc -ne 0 ]; then
          echo "passed=false" >> $GITHUB_OUTPUT
          echo "❌ Unit tests failed with exit code $rc"
          exit $rc
        else
          echo "passed=true" >> $GITHUB_OUTPUT
          echo "✅ Unit tests passed"
        fi

    - name: Generate coverage report
      id: coverage-report
      if: inputs.coverage == 'true'
      shell: bash
      run: |
        echo "📊 Generating coverage report..."

        PROJECT="${{ inputs.project }}"
        echo "🔎 Looking for coverage-summary.json for project: $PROJECT"

        FILES=()

        # Helper to add file if exists
        add_if_exists() {
          local f="$1"
          if [ -f "$f" ]; then
            FILES+=("$f")
            echo "  - found: $f"
          fi
        }

        if [ "$PROJECT" != "all" ]; then
          # Check common locations first
          add_if_exists "apps/$PROJECT/coverage/coverage-summary.json"
          add_if_exists "packages/$PROJECT/coverage/coverage-summary.json"
          add_if_exists "$PROJECT/coverage/coverage-summary.json"

          # If none found under the project, fall back to searching the repo
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "No coverage-summary.json under apps/$PROJECT or packages/$PROJECT — searching repository..."
            while IFS= read -r -d '' file; do FILES+=("$file"); done < <(find . -type f -name 'coverage-summary.json' -print0 2>/dev/null || true)
          fi
        else
          # project == all -> search entire repo
          echo "Project is 'all' — searching repository for coverage-summary.json files..."
          while IFS= read -r -d '' file; do FILES+=("$file"); done < <(find . -type f -name 'coverage-summary.json' -print0 2>/dev/null || true)
        fi

        # Deduplicate and normalize file paths
        if [ ${#FILES[@]} -gt 0 ]; then
          # Use associative array for dedupe
          declare -A seen
          UNIQUE=()
          for f in "${FILES[@]}"; do
            # normalize path
            nf=$(realpath --relative-to=. "$f" 2>/dev/null || printf "%s" "$f")
            if [ -z "${seen[$nf]}" ]; then
              seen[$nf]=1
              UNIQUE+=("$nf")
            fi
          done
          FILES=("${UNIQUE[@]}")
        fi

        count=${#FILES[@]}
        echo "🔢 Coverage files found: $count"
        for f in "${FILES[@]}"; do echo "  - $f"; done

        # No files -> clear fallback
        if [ $count -eq 0 ]; then
          echo "⚠️ No coverage-summary.json files found in repository."
          echo "percentage=unknown" >> $GITHUB_OUTPUT
          echo "percentage set to 'unknown' -> no coverage data available"
          exit 0
        fi

        # If exactly one file, extract percentage (prefer covered/total if available)
        if [ $count -eq 1 ]; then
          file="${FILES[0]}"
          echo "✅ Using single coverage file: $file"
          pct=$(jq -r '.total.lines.pct // empty' "$file" 2>/dev/null || true)
          if [ -n "$pct" ] && [ "$pct" != "null" ]; then
            # Ensure it's a number
            pct=$(printf "%.2f" "$pct" 2>/dev/null || printf "%s" "$pct")
            echo "percentage=$pct" >> $GITHUB_OUTPUT
            echo "📈 Coverage: $pct% (from .total.lines.pct in $file)"
            exit 0
          fi

          # Try compute from covered/total
          covered=$(jq -r '.total.lines.covered // empty' "$file" 2>/dev/null || true)
          total=$(jq -r '.total.lines.total // empty' "$file" 2>/dev/null || true)
          if [ -n "$covered" ] && [ -n "$total" ] && [ "$total" -gt 0 ] 2>/dev/null; then
            pct=$(awk "BEGIN {printf \"%.2f\", ($covered/$total)*100}")
            echo "percentage=$pct" >> $GITHUB_OUTPUT
            echo "📈 Coverage: $pct% (computed from covered=$covered / total=$total in $file)"
            exit 0
          fi

          echo "⚠️ Could not extract numeric coverage from $file"
          echo "percentage=unknown" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Multiple files: try weighted aggregation by lines if data available
        echo "🔀 Multiple coverage-summary.json files found — attempting aggregation..."
        sum_covered=0
        sum_total=0
        have_lines=false
        pct_list=()

        for file in "${FILES[@]}"; do
          c=$(jq -r '.total.lines.covered // empty' "$file" 2>/dev/null || true)
          t=$(jq -r '.total.lines.total // empty' "$file" 2>/dev/null || true)
          p=$(jq -r '.total.lines.pct // empty' "$file" 2>/dev/null || true)

          # Ensure numeric values
          if [[ "$c" =~ ^[0-9]+$ ]] && [[ "$t" =~ ^[0-9]+$ ]] && [ "$t" -gt 0 ] 2>/dev/null; then
            have_lines=true
            sum_covered=$((sum_covered + c))
            sum_total=$((sum_total + t))
            echo "  - $file -> covered=$c, total=$t"
          else
            if [ -n "$p" ] && [ "$p" != "null" ]; then
              # try to coerce p to number
              pct_list+=("$p")
              echo "  - $file -> pct=$p (no lines totals)"
            else
              echo "  - $file -> no usable lines or pct data"
            fi
          fi
        done

        if [ "$have_lines" = true ] && [ $sum_total -gt 0 ] 2>/dev/null; then
          pct=$(awk "BEGIN {printf \"%.2f\", ($sum_covered/$sum_total)*100}")
          echo "✅ Aggregated coverage (weighted by lines): covered=$sum_covered total=$sum_total -> $pct%"
          echo "percentage=$pct" >> $GITHUB_OUTPUT
          exit 0
        fi

        # No line counts available but we have pct values -> average them
        if [ ${#pct_list[@]} -gt 0 ]; then
          sum=0
          for v in "${pct_list[@]}"; do
            # remove possible quotes and coerce
            num=$(printf "%s" "$v" | tr -d '"')
            sum=$(awk "BEGIN {printf \"%.6f\", $sum + $num}")
          done
          avg=$(awk "BEGIN {printf \"%.2f\", $sum / ${#pct_list[@]}}")
          echo "✅ Aggregated coverage (simple average of pct fields): $avg%"
          echo "percentage=$avg" >> $GITHUB_OUTPUT
          exit 0
        fi

        # As a last resort, pick the most relevant file (prefer apps/<project>, packages/<project>, else the first)
        preferred=""
        for candidate in apps/*/coverage/coverage-summary.json packages/*/coverage/coverage-summary.json; do
          for f in "${FILES[@]}"; do
            if [ "$f" = "$candidate" ]; then preferred="$f"; break 2; fi
          done
        done
        if [ -z "$preferred" ]; then preferred="${FILES[0]}"; fi

        echo "⚠️ Could not aggregate coverage numerically; falling back to a best-effort file: $preferred"
        p=$(jq -r '.total.lines.pct // empty' "$preferred" 2>/dev/null || true)
        if [ -n "$p" ] && [ "$p" != "null" ]; then
          p=$(printf "%.2f" "$p" 2>/dev/null || printf "%s" "$p")
          echo "percentage=$p" >> $GITHUB_OUTPUT
          echo "📈 Coverage (from fallback file): $p% (file: $preferred)"
          exit 0
        fi

        echo "⚠️ No usable coverage percentage could be extracted from any coverage-summary.json"
        echo "percentage=unknown" >> $GITHUB_OUTPUT
        exit 0

    - name: Upload coverage to artifact
      if: inputs.upload-coverage == 'true' && inputs.coverage == 'true'
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
      with:
        name: coverage-${{ inputs.project }}-${{ github.sha }}
        path: |
          apps/*/coverage/
          coverage/
        retention-days: 14
        if-no-files-found: warn

    - name: Generate test summary
      shell: bash
      run: |
        echo "## 🧪 Unit Tests Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Project**: ${{ inputs.project }}" >> $GITHUB_STEP_SUMMARY
        
        # Check the actual test outcome
        if [ "${{ steps.run-tests.outcome }}" == "success" ]; then
          echo "- **Status**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
        else
          echo "- **Status**: ❌ Failed" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ inputs.coverage }}" == "true" ]; then
          COVERAGE="${{ steps.coverage-report.outputs.percentage }}"
          if [ "$COVERAGE" != "unknown" ] && [ "$COVERAGE" != "0" ]; then
            echo "- **Coverage**: $COVERAGE%" >> $GITHUB_STEP_SUMMARY
          fi
        fi
