{"version":3,"file":"index.js","sources":["../../../node_modules/@babel/runtime/helpers/classCallCheck.js","../src/classes/utils.ts","../../../node_modules/@babel/runtime/helpers/createClass.js","../src/classes/commands/annotation.ts","../../../node_modules/@babel/runtime/helpers/arrayWithHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","../../../node_modules/@babel/runtime/helpers/nonIterableRest.js","../../../node_modules/@babel/runtime/helpers/slicedToArray.js","../src/classes/commands/text.ts","../../../node_modules/@babel/runtime/helpers/defineProperty.js","../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../src/classes/commands/node.ts","../src/classes/commands/mark.ts","../src/classes/commands/selection.ts","../../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","../../../node_modules/@babel/runtime/helpers/iterableToArray.js","../../../node_modules/@babel/runtime/helpers/nonIterableSpread.js","../../../node_modules/@babel/runtime/helpers/toConsumableArray.js","../src/classes/commands/general.ts","../src/classes/queries/element.ts","../src/classes/queries/general.ts","../../../node_modules/regenerator-runtime/runtime.js","../../../node_modules/@babel/runtime/regenerator/index.js","../src/classes/queries/location.ts","../src/classes/queries/range.ts","../src/classes/editor.ts","../src/classes/path-ref.ts","../src/classes/point-ref.ts","../src/classes/range-ref.ts","../src/interfaces/element.ts","../src/interfaces/fragment.ts","../src/interfaces/location.ts","../src/interfaces/mark.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/point.ts","../src/interfaces/range.ts","../src/interfaces/text.ts","../src/interfaces/value.ts"],"sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","import { Editor, Node, Path, PathRef, PointRef, RangeRef, NodeEntry } from '..'\n\n/**\n * `Match` is a shorthand for a `NodeEntry` predicate for handling the most\n * common needs for rich text editing.\n */\n\nexport type Match =\n  | number\n  | 'value'\n  | 'block'\n  | 'inline'\n  | 'text'\n  | 'void'\n  | Partial<Node>\n  | Path\n  | ((entry: NodeEntry) => boolean)\n\n/**\n * Weak maps to keep track of instance-level editor state.\n */\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n\n/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nexport const isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  const code = text.charCodeAt(0)\n  const isSurrogate = SURROGATE_START <= code && code <= SURROGATE_END\n  return isSurrogate ? 2 : 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","import { Editor, Point, Range } from '../..'\n\nclass AnnotationCommands {\n  /**\n   * Add a new `annotation` object with a `key`.\n   */\n\n  addAnnotation(this: Editor, key: string, annotation: Range) {\n    this.apply({\n      type: 'add_annotation',\n      key,\n      annotation,\n    })\n  }\n\n  /**\n   * Remove an existing annotation object by `key`.\n   */\n\n  removeAnnotation(this: Editor, key: string) {\n    const { annotations } = this.value\n\n    if (!(key in annotations)) {\n      throw new Error(\n        `Unable to remove annotation by ${key} because it does not exist.`\n      )\n    }\n\n    const annotation = annotations[key]\n\n    this.apply({\n      type: 'remove_annotation',\n      key,\n      annotation,\n    })\n  }\n\n  /**\n   * Set new properties on an annotation object with `key`.\n   */\n\n  setAnnotation(this: Editor, key: string, props: Partial<Range>) {\n    const { annotations } = this.value\n\n    if (!(key in annotations)) {\n      throw new Error(\n        `Unable to set new properties on annotation by ${key} because it does not exist.`\n      )\n    }\n\n    const annotation = annotations[key]\n    const newProps = {}\n    const prevProps = {}\n\n    for (const k in props) {\n      const isPoint = k === 'anchor' || k === 'focus'\n\n      if (\n        (isPoint && !Point.equals(props[k], annotation[k])) ||\n        (!isPoint && props[k] !== annotation[k])\n      ) {\n        newProps[k] = props[k]\n        prevProps[k] = annotation[k]\n      }\n    }\n\n    if (Object.keys(newProps).length > 0) {\n      this.apply({\n        type: 'set_annotation',\n        key,\n        properties: prevProps,\n        newProperties: newProps,\n      })\n    }\n  }\n}\n\nexport default AnnotationCommands\n","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nmodule.exports = _arrayWithHoles;","function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nmodule.exports = _iterableToArrayLimit;","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nmodule.exports = _nonIterableRest;","var arrayWithHoles = require(\"./arrayWithHoles\");\n\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit\");\n\nvar nonIterableRest = require(\"./nonIterableRest\");\n\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}\n\nmodule.exports = _slicedToArray;","import {\n  Editor,\n  Element,\n  Fragment,\n  Path,\n  Location,\n  Range,\n  Point,\n  Value,\n} from '../..'\n\nclass DeletingCommands {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    this: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const { reverse = false, unit = 'character', distance = 1 } = options\n      let { at = this.value.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = this.getMatch(at.path, 'void')\n\n        if (furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? this.getBefore(at, opts) || this.getStart([])\n            : this.getAfter(at, opts) || this.getEnd([])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        this.removeNodes({ at })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        at = this.unhangRange(at)\n      }\n\n      let [start, end] = Range.edges(at)\n      const [ancestor] = this.getAncestor(at)\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = this.getMatch(start.path, 'void')\n      const endVoid = this.getMatch(end.path, 'void')\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const block = this.getMatch(start.path, 'block')\n        const before = this.getBefore(start)\n\n        if (before && block && Path.isAncestor(block[1], before.path)) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const block = this.getMatch(end.path, 'block')\n        const after = this.getAfter(end)\n\n        if (after && block && Path.isAncestor(block[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches = this.matches({\n        at,\n        match: ([n, p]) =>\n          (Element.isElement(n) && this.isVoid(n)) ||\n          (!Path.isCommon(p, start.path) && !Path.isCommon(p, end.path)),\n      })\n\n      const pathRefs = Array.from(matches, ([, p]) => this.createPathRef(p))\n      const startRef = this.createPointRef(start)\n      const endRef = this.createPointRef(end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = this.getLeaf(point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        this.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        this.removeNodes({ at: path })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = this.getLeaf(point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        this.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      const isBlockAncestor =\n        Value.isValue(ancestor) ||\n        (Element.isElement(ancestor) && !this.isInline(ancestor))\n\n      if (\n        !isSingleText &&\n        isBlockAncestor &&\n        endRef.current &&\n        startRef.current\n      ) {\n        this.mergeNodes({ at: endRef.current, hanging: true })\n      }\n\n      const point = endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        this.select(point)\n      }\n    })\n  }\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    this: Editor,\n    fragment: Fragment,\n    options: {\n      at?: Location\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const { selection } = this.value\n      let { at } = options\n      let isSelection = false\n\n      if (!at && selection) {\n        at = selection\n        isSelection = true\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Range.isRange(at)) {\n        const [, end] = Range.edges(at)\n        const pointRef = this.createPointRef(end)\n        this.delete({ at })\n        at = pointRef.unref()!\n      }\n\n      if (!Point.isPoint(at) || this.getMatch(at.path, 'void')) {\n        return\n      }\n\n      const pointRef = this.createPointRef(at)\n      this.splitNodes({ at, always: true })\n\n      if (pointRef.current) {\n        const [, insertPath] = this.getMatch(pointRef.current.path, 'block')!\n        this.insertNodes(fragment.nodes, { at: insertPath })\n\n        const afterClosest = this.getMatch(pointRef.current.path, 'block')\n        const beforeClosest = this.getMatch(at.path, 'block')\n\n        if (afterClosest && beforeClosest) {\n          const [, afterPath] = afterClosest\n          const [, beforePath] = beforeClosest\n          const startPath = Path.next(beforePath)\n          this.mergeNodes({ at: afterPath })\n          this.mergeNodes({ at: startPath })\n        }\n      }\n\n      if (isSelection) {\n        this.select(pointRef.current!)\n      }\n\n      pointRef.unref()\n    })\n  }\n\n  /**\n   * Insert a string of text in the editor.\n   */\n\n  insertText(\n    this: Editor,\n    text: string,\n    options: {\n      at?: Point | Range\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const { selection } = this.value\n      let { at } = options\n\n      if (!at && selection) {\n        at = selection\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const pointRef = this.createPointRef(Range.end(at))\n          this.delete({ at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at) && !this.getMatch(at.path, 'void')) {\n        const { path, offset } = at\n        this.apply({ type: 'insert_text', path, offset, text })\n      }\n    })\n  }\n\n  /**\n   * Remove a string of text in the editor.\n   */\n\n  removeText(\n    this: Editor,\n    text: string,\n    options: {\n      at?: Range\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      let { at = this.value.selection } = options\n\n      if (!at || Range.isCollapsed(at)) {\n        return\n      }\n\n      const [start, end] = Range.edges(at)\n      const texts = this.texts({ at })\n      const pathRefs = Array.from(texts, ([, p]) => this.createPathRef(p))\n\n      for (const [node, path] of this.texts({ at }))\n        if (Point.isPoint(at) && !this.getMatch(at.path, 'void')) {\n          const { path, offset } = at\n          this.apply({ type: 'insert_text', path, offset, text })\n        }\n    })\n  }\n}\n\nexport default DeletingCommands\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;","import {\n  Descendant,\n  Editor,\n  Node,\n  NodeEntry,\n  Element,\n  Location,\n  Path,\n  Text,\n  Range,\n  Point,\n} from '../..'\nimport { Match } from '../utils'\n\nclass NodeCommands {\n  /**\n   * Insert nodes at a specific location in the editor.\n   */\n\n  insertNodes(\n    this: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: Match\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const { selection } = this.value\n      let { at, match } = options\n      let select = false\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = at.length\n        } else if (Text.isText(node)) {\n          match = 'text'\n        } else if (this.isInline(node)) {\n          match = 'inline'\n        } else {\n          match = 'block'\n        }\n      }\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        at = selection || this.getEnd([]) || [this.value.nodes.length]\n        select = true\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = this.createPointRef(end)\n          this.delete({ at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        const atMatch = this.getMatch(at.path, match)\n\n        if (atMatch) {\n          const [, matchPath] = atMatch\n          const pathRef = this.createPathRef(matchPath)\n          const isAtEnd = this.isEnd(at, matchPath)\n          this.splitNodes({ at, match })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (this.getMatch(parentPath, 'void')) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        this.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = this.getEnd(at)\n\n        if (point) {\n          this.select(point)\n        }\n      }\n    })\n  }\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes(\n    this: Editor,\n    options: {\n      at?: Location\n      match?: Match\n    }\n  ) {\n    this.withoutNormalizing(() => {\n      const {\n        at = this.value.selection,\n        match = Path.isPath(at) ? at.length : 'block',\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      const matches = this.matches({ at, match })\n      const pathRefs = Array.from(matches, ([, p]) => this.createPathRef(p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const [parent, parentPath] = this.getNode(Path.parent(path))\n        const index = path[path.length - 1]\n        const { length } = parent.nodes\n\n        if (length === 1) {\n          this.moveNodes({ at: path, to: Path.next(parentPath) })\n          this.removeNodes({ at: parentPath })\n        } else if (index === 0) {\n          this.moveNodes({ at: path, to: parentPath })\n        } else if (index === length - 1) {\n          this.moveNodes({ at: path, to: Path.next(parentPath) })\n        } else {\n          this.splitNodes({ at: Path.next(path) })\n          this.moveNodes({ at: path, to: Path.next(parentPath) })\n        }\n      }\n    })\n  }\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes(\n    this: Editor,\n    options: {\n      at?: Location\n      match?: Match\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      let { at = this.value.selection } = options\n      const {\n        match = Path.isPath(at) ? at.length : 'block',\n        hanging = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = this.unhangRange(at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = this.createPointRef(end)\n          this.delete({ at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            this.select(at)\n          }\n        }\n      }\n\n      const current = this.getMatch(at, match)\n      const prev = this.getPrevious(at, match)\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Node.furthest(this.value, path, ([n, p]) => {\n        return (\n          Path.isDescendant(p, commonPath) &&\n          Path.isAncestor(p, path) &&\n          Element.isElement(n) &&\n          n.nodes.length === 1\n        )\n      })\n\n      const emptyRef = emptyAncestor && this.createPathRef(emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, marks, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { nodes, ...rest } = node\n        position = prevNode.nodes.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        this.moveNodes({ at: path, to: newPath })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        this.removeNodes({ at: emptyRef.current! })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && this.isEmpty(prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        this.removeNodes({ at: prevPath })\n      } else {\n        this.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          target: null,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  }\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes(\n    this: Editor,\n    options: {\n      at?: Location\n      match?: Match\n      to: Path\n    }\n  ) {\n    this.withoutNormalizing(() => {\n      const {\n        to,\n        at = this.value.selection,\n        match = Path.isPath(at) ? at.length : 'block',\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      const toRef = this.createPathRef(to)\n      const targets = this.matches({ at, match })\n      const pathRefs = Array.from(targets, ([, p]) => this.createPathRef(p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          this.apply({ type: 'move_node', path, newPath })\n        }\n      }\n\n      toRef.unref()\n    })\n  }\n\n  /**\n   * Normalize a node at a path, returning it to a valid state if it is\n   * currently invalid.\n   */\n\n  normalizeNodes(this: Editor, options: { at: Path }): void {\n    const { at } = options\n    const [node] = this.getNode(at)\n\n    // There are no core normalizations for text nodes.\n    if (Text.isText(node)) {\n      return\n    }\n\n    // Ensure that block and inline nodes have at least one text child.\n    if (Element.isElement(node) && node.nodes.length === 0) {\n      const child = { text: '', marks: [] }\n      this.insertNodes(child, { at: at.concat(0) })\n      return\n    }\n\n    // Determine whether the node should have block or inline children.\n    const shouldHaveInlines =\n      Element.isElement(node) &&\n      (this.isInline(node) ||\n        node.nodes.length === 0 ||\n        Text.isText(node.nodes[0]) ||\n        this.isInline(node.nodes[0]))\n\n    // Since we'll be applying operations while iterating, keep track of an\n    // index that accounts for any added/removed nodes.\n    let n = 0\n\n    for (let i = 0; i < node.nodes.length; i++, n++) {\n      const child = node.nodes[i] as Descendant\n      const prev = node.nodes[i - 1]\n      const isLast = i === node.nodes.length - 1\n\n      if (Element.isElement(child)) {\n        const isInline = this.isInline(child)\n\n        // Only allow block nodes in the top-level value and parent blocks that\n        // only contain block nodes. Similarly, only allow inline nodes in other\n        // inline nodes, or parent blocks that only contain inlines and text.\n        if (isInline !== shouldHaveInlines) {\n          this.removeNodes({ at: at.concat(n) })\n          n--\n          continue\n        }\n\n        // Ensure that inline nodes are surrounded by text nodes.\n        if (isInline) {\n          if (prev == null || !Text.isText(prev)) {\n            const child = { text: '', marks: [] }\n            this.insertNodes(child, { at: at.concat(n) })\n            n++\n            continue\n          }\n\n          if (isLast) {\n            const child = { text: '', marks: [] }\n            this.insertNodes(child, { at: at.concat(n + 1) })\n            n++\n            continue\n          }\n        }\n      } else {\n        // Merge adjacent text nodes that are empty or have matching marks.\n        if (prev != null && Text.isText(prev)) {\n          if (Text.matches(child, prev)) {\n            this.mergeNodes({ at: at.concat(n) })\n            n--\n            continue\n          } else if (prev.text === '') {\n            this.removeNodes({ at: at.concat(n - 1) })\n            n--\n            continue\n          } else if (isLast && child.text === '') {\n            this.removeNodes({ at: at.concat(n) })\n            n--\n            continue\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes(\n    this: Editor,\n    options: {\n      at?: Location\n      match?: Match\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      let { at = this.value.selection } = options\n      const {\n        match = Path.isPath(at) ? at.length : 'block',\n        hanging = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = this.unhangRange(at)\n      }\n\n      const depths = this.matches({ at, match })\n      const pathRefs = Array.from(depths, ([, p]) => this.createPathRef(p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = this.getNode(path)\n        this.apply({ type: 'remove_node', path, node })\n      }\n    })\n  }\n\n  /**\n   * Set new properties on the nodes ...\n   */\n\n  setNodes(\n    this: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: Match\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      let { at = this.value.selection } = options\n      const {\n        match = Path.isPath(at) ? at.length : 'block',\n        hanging = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = this.unhangRange(at)\n      }\n\n      for (const [node, path] of this.matches({ at, match })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        for (const k in props) {\n          if (\n            k === 'annotations' ||\n            k === 'marks' ||\n            k === 'nodes' ||\n            k === 'selection' ||\n            k === 'text'\n          ) {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          this.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  }\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes(\n    this: Editor,\n    options: {\n      at?: Location\n      match?: Match\n      always?: boolean\n      height?: number\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      let {\n        match,\n        at = this.value.selection,\n        height = 0,\n        always = false,\n      } = options\n\n      if (match == null) {\n        match = Path.isPath(at) ? at.length : 'block'\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(this, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const point = this.getPoint(at)\n        match = at.length - 1\n        height = point.path.length - at.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = this.createPointRef(at, { affinity: 'backward' })\n      const highest = this.getMatch(at, match)\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = this.getMatch(at, 'void')\n      let nudge = 0\n\n      if (voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && this.isInline(voidNode)) {\n          let after = this.getAfter(voidPath)\n\n          if (!after) {\n            const text = { text: '', marks: [] }\n            const afterPath = Path.next(voidPath)\n            this.insertNodes(text, { at: afterPath })\n            after = this.getPoint(afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = this.createPointRef(at)\n      const depth = at.path.length - height\n      let [, highestPath] = highest\n      let lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n      let target: number | null = null\n\n      for (const [node, path] of this.levels({\n        at: lowestPath,\n        reverse: true,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (Element.isElement(node) && this.isVoid(node))\n        ) {\n          break\n        }\n\n        if (always || !beforeRef || !this.isEdge(beforeRef.current!, path)) {\n          const { text, marks, nodes, ...properties } = node\n          this.apply({ type: 'split_node', path, position, target, properties })\n          split = true\n        }\n\n        target = position\n        position = path[path.length - 1] + (split ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || this.getEnd([])\n        this.select(point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  }\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes(\n    this: Editor,\n    options: {\n      at?: Location\n      match?: Match\n      split?: boolean\n    }\n  ) {\n    this.withoutNormalizing(() => {\n      const {\n        at = this.value.selection,\n        match = Path.isPath(at) ? at.length : 'block',\n        split = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      const matches = this.matches({ at, match })\n      const pathRefs = Array.from(matches, ([, p]) => this.createPathRef(p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const depth = path.length + 1\n        let range = this.getRange(path)\n\n        if (split && Range.isRange(at)) {\n          range = Range.intersection(at, range)!\n        }\n\n        this.liftNodes({ at: range, match: depth })\n      }\n    })\n  }\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes(\n    this: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: Match\n      split?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const { split = false } = options\n      let { match, at = this.value.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = at.length\n        } else if (this.isInline(element)) {\n          match = 'inline'\n        } else {\n          match = 'block'\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = this.createRangeRef(at, { affinity: 'inward' })\n        this.splitNodes({ at: end, match })\n        this.splitNodes({ at: start, match })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          this.select(at)\n        }\n      }\n\n      const roots: NodeEntry[] = this.isInline(element)\n        ? Array.from(this.matches({ ...options, at, match: 'block' }))\n        : [[this.value, []]]\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, this.getRange(rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(this.matches({ ...options, at: a, match }))\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = this.getRange(firstPath, lastPath)\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath).slice(0, depth)\n          const wrapper = { ...element, nodes: [] }\n          this.insertNodes(wrapper, { at: wrapperPath })\n          this.moveNodes({\n            at: range,\n            match: depth,\n            to: wrapperPath.concat(0),\n          })\n        }\n      }\n    })\n  }\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = editor.createPointRef(end)\n    editor.delete({ at: range })\n    return pointRef.unref()\n  }\n}\n\nexport default NodeCommands\n","import { Editor, Mark, Location, Range } from '../..'\n\nclass MarkCommands {\n  /**\n   * Add a set of marks to the text nodes at a location.\n   */\n\n  addMarks(\n    this: Editor,\n    marks: Mark[],\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const at = splitLocation(this, options)\n\n      if (!at) {\n        return\n      }\n\n      // De-dupe the marks being added to ensure the set is unique.\n      const set: Mark[] = []\n\n      for (const mark of marks) {\n        if (!Mark.exists(mark, set)) {\n          set.push(mark)\n        }\n      }\n\n      for (const [node, path] of this.texts({ at })) {\n        for (const mark of set) {\n          if (!Mark.exists(mark, node.marks)) {\n            this.apply({ type: 'add_mark', path, mark })\n          }\n        }\n      }\n    })\n  }\n\n  removeMarks(\n    this: Editor,\n    marks: Mark[],\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const at = splitLocation(this, options)\n\n      if (at) {\n        for (const [mark, i, node, path] of this.marks({ at })) {\n          if (Mark.exists(mark, marks)) {\n            this.apply({ type: 'remove_mark', path, mark })\n          }\n        }\n      }\n    })\n  }\n\n  setMarks(\n    this: Editor,\n    marks: Mark[],\n    props: Partial<Mark>,\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const at = splitLocation(this, options)\n\n      if (at) {\n        for (const [mark, i, node, path] of this.marks({ at })) {\n          if (Mark.exists(mark, marks)) {\n            const newProps = {}\n\n            for (const k in props) {\n              if (props[k] !== mark[k]) {\n                newProps[k] = props[k]\n              }\n            }\n\n            if (Object.keys(newProps).length > 0) {\n              this.apply({\n                type: 'set_mark',\n                path,\n                properties: mark,\n                newProperties: newProps,\n              })\n            }\n          }\n        }\n      }\n    })\n  }\n\n  toggleMarks(\n    this: Editor,\n    marks: Mark[],\n    options: {\n      at?: Location\n      hanging?: boolean\n    } = {}\n  ) {\n    this.withoutNormalizing(() => {\n      const existing = this.getActiveMarks(options)\n      const exists = marks.every(m => Mark.exists(m, existing))\n\n      if (exists) {\n        this.removeMarks(marks, options)\n      } else {\n        this.addMarks(marks, options)\n      }\n    })\n  }\n}\n\n/**\n * Split the text nodes at a range's edges to prepare for adding/removing marks.\n */\n\nconst splitLocation = (\n  editor: Editor,\n  options: {\n    at?: Location\n    hanging?: boolean\n  } = {}\n): Location | undefined => {\n  let { at = editor.value.selection, hanging = false } = options\n\n  if (!at) {\n    return\n  }\n\n  if (Range.isRange(at)) {\n    if (!hanging) {\n      at = editor.unhangRange(at)\n    }\n\n    const rangeRef = editor.createRangeRef(at, { affinity: 'inward' })\n    const [start, end] = Range.edges(at)\n    editor.splitNodes({ at: end, match: 'text' })\n    editor.splitNodes({ at: start, match: 'text' })\n    const range = rangeRef.unref()!\n\n    if (options.at == null) {\n      editor.select(range)\n    }\n\n    return range\n  }\n\n  return at\n}\n\nexport default MarkCommands\n","import { Editor, Location, Point, Range, Path } from '../..'\n\nclass SelectionCommands {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    this: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { edge = 'anchor' } = options\n    const { selection } = this.value\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      this.select(selection.anchor)\n    } else if (edge === 'focus') {\n      this.select(selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      this.select(start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      this.select(end)\n    }\n  }\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(this: Editor) {\n    const { selection } = this.value\n\n    if (selection) {\n      this.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  }\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    this: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { selection } = this.value\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? this.getBefore(anchor, opts)\n        : this.getAfter(anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? this.getBefore(focus, opts)\n        : this.getAfter(focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    this.setSelection(props)\n  }\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(this: Editor, target: Location) {\n    const { selection } = this.value\n    target = this.getRange(target)\n\n    if (selection) {\n      this.setSelection(target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    this.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  }\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    this: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) {\n    const { selection } = this.value\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n    const newPoint = Object.assign(point, props)\n\n    if (edge === 'anchor') {\n      this.setSelection({ anchor: newPoint })\n    } else {\n      this.setSelection({ focus: newPoint })\n    }\n  }\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(this: Editor, props: Partial<Range>) {\n    const { selection } = this.value\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      this.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  }\n}\n\nexport default SelectionCommands\n","function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","function _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","import { Operation, Editor, Node, Path, Text, Value } from '../..'\nimport {\n  DIRTY_PATHS,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n  FLUSHING,\n  NORMALIZING,\n} from '../utils'\n\nclass GeneralCommands {\n  apply(this: Editor, op: Operation): void {\n    this.value = Value.transform(this.value, op)\n    this.operations.push(op)\n\n    for (const ref of PATH_REFS.get(this)!) {\n      ref.transform(op)\n    }\n\n    for (const ref of POINT_REFS.get(this)!) {\n      ref.transform(op)\n    }\n\n    for (const ref of RANGE_REFS.get(this)!) {\n      ref.transform(op)\n    }\n\n    const pathCache = {}\n    const dirtyPaths: Path[] = []\n    const add = (path: Path | null) => {\n      if (path == null) {\n        return\n      }\n\n      const key = path.join(',')\n\n      if (key in pathCache) {\n        return\n      }\n\n      pathCache[key] = true\n      dirtyPaths.push(path)\n    }\n\n    for (const path of DIRTY_PATHS.get(this)!) {\n      add(Path.transform(path, op))\n    }\n\n    for (const path of getDirtyPaths(op)) {\n      add(path)\n    }\n\n    DIRTY_PATHS.set(this, dirtyPaths)\n    this.normalize()\n\n    if (!FLUSHING.get(this)) {\n      FLUSHING.set(this, true)\n      Promise.resolve().then(() => this.flush())\n    }\n  }\n\n  flush(this: Editor): void {\n    FLUSHING.set(this, false)\n    const { value, operations } = this\n\n    if (operations.length !== 0) {\n      this.operations = []\n      this.onChange(value, operations)\n    }\n  }\n\n  normalize(\n    this: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ): void {\n    const { force = false } = options\n\n    if (!NORMALIZING.get(this)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(this.value), ([, p]) => p)\n      DIRTY_PATHS.set(this, allPaths)\n    }\n\n    if (DIRTY_PATHS.get(this)!.length === 0) {\n      return\n    }\n\n    this.withoutNormalizing(() => {\n      const max = DIRTY_PATHS.get(this)!.length * 42 // HACK: better way to do this?\n      let m = 0\n\n      while (DIRTY_PATHS.get(this)!.length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the value after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const path = DIRTY_PATHS.get(this)!.pop()\n        this.normalizeNodes({ at: path! })\n        m++\n      }\n    })\n  }\n\n  withoutNormalizing(this: Editor, fn: () => void): void {\n    const value = NORMALIZING.get(this)!\n    NORMALIZING.set(this, false)\n    fn()\n    NORMALIZING.set(this, value)\n    this.normalize()\n  }\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation) => {\n  switch (op.type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const path = Path.transform(ancestor, op)\n        oldAncestors.push(path!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const path = Path.transform(ancestor, op)\n        newAncestors.push(path!)\n      }\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n\nexport default GeneralCommands\n","import { Editor, Element, Text } from '../..'\n\nclass ElementQueries {\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(this: Editor, element: Element): boolean {\n    return element.nodes.some(n => Element.isElement(n) && !this.isInline(n))\n  }\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(this: Editor, element: Element): boolean {\n    return element.nodes.some(\n      n => Text.isText(n) || (Element.isElement(n) && this.isInline(n))\n    )\n  }\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(this: Editor, element: Element): boolean {\n    return element.nodes.every(n => Text.isText(n))\n  }\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(this: Editor, element: Element): boolean {\n    const { nodes } = element\n    const [first] = nodes\n    return (\n      nodes.length === 0 ||\n      (nodes.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !this.isVoid(element))\n    )\n  }\n\n  /**\n   * Check if a node is an inline, meaning that it lives intermixed with text\n   * nodes in the document tree.\n   */\n\n  isInline(this: Editor, element: Element): boolean {\n    return false\n  }\n\n  /**\n   * Check if a node is a void, meaning that Slate considers its content a black\n   * box. It will be edited as if it has no content.\n   */\n\n  isVoid(this: Editor, element: Element): boolean {\n    return false\n  }\n}\n\nexport default ElementQueries\n","import { Editor, Path, Point, PathRef, PointRef, Range, RangeRef } from '../..'\n\nclass GeneralQueries {\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the this.\n   */\n\n  createPathRef(\n    this: Editor,\n    path: Path,\n    options: { affinity?: 'backward' | 'forward' | null } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = new PathRef({ path, affinity, editor: this })\n    return ref\n  }\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the this.\n   */\n\n  createPointRef(\n    this: Editor,\n    point: Point,\n    options: { affinity?: 'backward' | 'forward' | null } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = new PointRef({ point, affinity, editor: this })\n    return ref\n  }\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the this.\n   */\n\n  createRangeRef(\n    this: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = new RangeRef({ range, affinity, editor: this })\n    return ref\n  }\n}\n\nexport default GeneralQueries\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","module.exports = require(\"regenerator-runtime\");\n","import { reverse as reverseText } from 'esrever'\nimport {\n  Ancestor,\n  AncestorEntry,\n  AnnotationEntry,\n  Editor,\n  Element,\n  ElementEntry,\n  Location,\n  Mark,\n  MarkEntry,\n  Node,\n  NodeEntry,\n  Path,\n  Point,\n  Range,\n  Fragment,\n  Span,\n  Text,\n  TextEntry,\n  Value,\n} from '../..'\nimport { Match, getCharacterDistance, getWordDistance } from '../utils'\n\nclass LocationQueries {\n  /**\n   * Iterate through all of the annotations in the editor.\n   */\n\n  *annotations(\n    this: Editor,\n    options: {\n      at?: Location\n    } = {}\n  ): Iterable<AnnotationEntry> {\n    const { annotations, selection } = this.value\n    const { at = selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = this.getRange(at)\n\n    for (const key in annotations) {\n      const annotation = annotations[key]\n\n      if (at && !Range.includes(range, annotation)) {\n        continue\n      }\n\n      yield [annotation, key]\n    }\n  }\n\n  /**\n   * Iterate through all of the elements in the editor.\n   */\n\n  *elements(\n    this: Editor,\n    options: {\n      at?: Location | Span\n      reverse?: boolean\n    } = {}\n  ): Iterable<ElementEntry> {\n    const { at = this.value.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [from, to] = getSpan(this, at, options)\n\n    yield* Node.elements(this.value, {\n      ...options,\n      from,\n      to,\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\n    })\n  }\n\n  /**\n   * Get the marks that are \"active\" at a location. These are the\n   * marks that will be added to any text that is inserted.\n   *\n   * The `union: true` option can be passed to create a union of marks across\n   * the text nodes in the selection, instead of creating an intersection, which\n   * is the default.\n   *\n   * Note: to obey common rich text behavior, if the selection is collapsed at\n   * the start of a text node and there are previous text nodes in the same\n   * block, it will carry those marks forward from the previous text node. This\n   * allows for continuation of marks from previous words.\n   */\n\n  getActiveMarks(\n    this: Editor,\n    options: {\n      at?: Location\n      union?: boolean\n      hanging?: boolean\n    } = {}\n  ): Mark[] {\n    const { union = false, hanging = false } = options\n    let { at = this.value.selection } = options\n\n    if (!at) {\n      return []\n    }\n\n    at = this.getRange(at)\n\n    if (!hanging) {\n      at = this.unhangRange(at)\n    }\n\n    // If the range is collapsed at the start of a text node, it should carry\n    // over the marks from the previous text node in the same block.\n    if (Range.isCollapsed(at) && at.anchor.offset === 0) {\n      const { anchor } = at\n      const prev = this.getPrevious(anchor, 'text')\n\n      if (prev && Path.isSibling(anchor.path, prev[1])) {\n        const [prevNode, prevPath] = prev\n\n        if (Text.isText(prevNode)) {\n          at = this.getRange(prevPath)\n        }\n      }\n    }\n\n    const marks: Mark[] = []\n    let first = true\n\n    for (const [node] of this.texts({ at })) {\n      if (first) {\n        marks.push(...node.marks)\n        first = false\n        continue\n      }\n\n      if (union) {\n        for (const mark of node.marks) {\n          if (!Mark.exists(mark, marks)) {\n            marks.push(mark)\n          }\n        }\n      } else {\n        // PERF: If we're doing an intersection and the result hits zero it can\n        // never increase again, so we can exit early.\n        if (marks.length === 0) {\n          break\n        }\n\n        // Iterate backwards so that removing marks doesn't impact indexing.\n        for (let i = marks.length - 1; i >= 0; i--) {\n          const existing = marks[i]\n\n          if (!Mark.exists(existing, node.marks)) {\n            marks.splice(i, 1)\n          }\n        }\n      }\n    }\n\n    return marks\n  }\n\n  /**\n   * Get the point after a location.\n   */\n\n  getAfter(\n    this: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = this.getPoint(at, { edge: 'end' })\n    const focus = this.getEnd([])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of this.positions({ ...options, at: range })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  }\n\n  /**\n   * Get the common ancestor node of a location.\n   */\n\n  getAncestor(\n    this: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): AncestorEntry {\n    if (Path.isPath(at) || Point.isPoint(at)) {\n      return this.getParent(at, options)\n    }\n\n    const path = this.getPath(at, options)\n    const ancestorPath = Path.equals(at.anchor.path, at.focus.path)\n      ? Path.parent(path)\n      : path\n\n    const ancestor = Node.get(this.value, ancestorPath) as Ancestor\n    return [ancestor, ancestorPath]\n  }\n\n  /**\n   * Get the point before a location.\n   */\n\n  getBefore(\n    this: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = this.getStart([])\n    const focus = this.getPoint(at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of this.positions({ ...options, at: range, reverse: true })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  }\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  getEdges(this: Editor, at: Location): [Point, Point] {\n    return [this.getStart(at), this.getEnd(at)]\n  }\n\n  /**\n   * Get the end point of a location.\n   */\n\n  getEnd(this: Editor, at: Location): Point {\n    return this.getPoint(at, { edge: 'end' })\n  }\n\n  /**\n   * Get the first node at a location.\n   */\n\n  getFirst(this: Editor, at: Location): NodeEntry {\n    const path = this.getPath(at, { edge: 'start' })\n    return this.getNode(path)\n  }\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  getFragment(this: Editor, at: Location): Fragment {\n    const range = this.getRange(at)\n    const fragment = Node.fragment(this.value, range)\n    return fragment\n  }\n\n  /**\n   * Get the last node at a location.\n   */\n\n  getLast(this: Editor, at: Location): NodeEntry {\n    const path = this.getPath(at, { edge: 'end' })\n    return this.getNode(path)\n  }\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  getLeaf(\n    this: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): TextEntry {\n    const path = this.getPath(at, options)\n    const node = Node.leaf(this.value, path)\n    return [node, path]\n  }\n\n  /**\n   * Get the first matching node in a single branch of the document.\n   */\n\n  getMatch(this: Editor, at: Location, match: Match): NodeEntry | undefined {\n    // PERF: If the match is a path, don't traverse.\n    if (Path.isPath(match)) {\n      return this.getNode(match)\n    }\n\n    // PERF: If the target is a path and the match is a depth, don't traverse.\n    if (typeof match === 'number' && match <= at.length && Path.isPath(at)) {\n      const p = at.slice(0, match)\n      return this.getNode(p)\n    }\n\n    const path = this.getPath(at)\n\n    for (const entry of this.levels({ at: path })) {\n      if (isMatch(this, entry, match)) {\n        return entry\n      }\n    }\n  }\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  getNext(this: Editor, at: Location, match: Match): NodeEntry | undefined {\n    const [, from] = this.getLast(at)\n    const [, to] = this.getLast([])\n    const span: Span = [from, to]\n    let i = 0\n\n    for (const entry of this.matches({ at: span, match })) {\n      if (i === 1) {\n        return entry\n      }\n\n      i++\n    }\n  }\n\n  /**\n   * Get the node at a location.\n   */\n\n  getNode(\n    this: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = this.getPath(at, options)\n    const node = Node.get(this.value, path)\n    return [node, path]\n  }\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  getParent(\n    this: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): AncestorEntry {\n    const path = this.getPath(at, options)\n    const parentPath = Path.parent(path)\n    const entry = this.getNode(parentPath)\n    return entry as AncestorEntry\n  }\n\n  /**\n   * Get the path of a location.\n   */\n\n  getPath(\n    this: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(this.value, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(this.value, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  }\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  getPoint(\n    this: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(this.value, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(this.value, at)\n        path = firstPath\n      }\n\n      const node = Node.get(this.value, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  }\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  getPrevious(this: Editor, at: Location, match: Match): NodeEntry | undefined {\n    const [, from] = this.getFirst(at)\n    const [, to] = this.getFirst([])\n    const span: Span = [from, to]\n    let i = 0\n\n    for (const entry of this.matches({ match, at: span, reverse: true })) {\n      if (i === 1) {\n        return entry\n      }\n\n      i++\n    }\n  }\n\n  /**\n   * Get a range of a location.\n   */\n\n  getRange(this: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = this.getStart(at)\n    const end = this.getEnd(to || at)\n    return { anchor: start, focus: end }\n  }\n\n  /**\n   * Get the start point of a location.\n   */\n\n  getStart(this: Editor, at: Location): Point {\n    return this.getPoint(at, { edge: 'start' })\n  }\n\n  /**\n   * Get the text content of a location.\n   *\n   * Note: the text of void nodes is presumed to be an empty string, regardless\n   * of what their actual content is.\n   */\n\n  getText(this: Editor, at: Location): string {\n    const range = this.getRange(at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of this.texts({ at: range })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  }\n\n  /**\n   * Check if there is a node at a location.\n   */\n\n  hasNode(\n    this: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): boolean {\n    const path = this.getPath(at, options)\n    const exists = Node.has(this.value, path)\n    return exists\n  }\n\n  /**\n   * Check if a point the start point of a location.\n   */\n\n  isStart(this: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = this.getStart(at)\n    return Point.equals(point, start)\n  }\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(this: Editor, point: Point, at: Location): boolean {\n    const end = this.getEnd(at)\n    return Point.equals(point, end)\n  }\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(this: Editor, point: Point, at: Location): boolean {\n    return this.isStart(point, at) || this.isEnd(point, at)\n  }\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels(\n    this: Editor,\n    options: {\n      at?: Location\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { at = this.value.selection, reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry[] = []\n    const path = this.getPath(at)\n\n    for (const [n, p] of Node.levels(this.value, path)) {\n      levels.push([n, p])\n\n      if (Element.isElement(n) && this.isVoid(n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  }\n\n  /**\n   * Iterate through all of the text nodes in the editor.\n   */\n\n  *marks(\n    this: Editor,\n    options: {\n      at?: Location | Span\n      reverse?: boolean\n    } = {}\n  ): Iterable<MarkEntry> {\n    const { at = this.value.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [from, to] = getSpan(this, at, options)\n\n    yield* Node.marks(this.value, {\n      ...options,\n      from,\n      to,\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\n    })\n  }\n\n  /**\n   * Iterate through all of the nodes that match.\n   */\n\n  *matches(\n    this: Editor,\n    options: {\n      at?: Location | Span\n      match?: Match\n      reverse?: boolean\n    }\n  ): Iterable<NodeEntry> {\n    const {\n      at = this.value.selection,\n      match = Path.isPath(at) ? at : () => true,\n      reverse = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    let prevPath: Path | undefined\n\n    for (const [n, p] of this.nodes({ at, reverse })) {\n      if (prevPath && Path.compare(p, prevPath) === 0) {\n        continue\n      }\n\n      if (isMatch(this, [n, p], match)) {\n        prevPath = p\n        yield [n, p]\n      }\n    }\n  }\n\n  /**\n   * Iterate through all of the nodes in the editor.\n   */\n\n  *nodes(\n    this: Editor,\n    options: {\n      at?: Location | Span\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { at = this.value.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [from, to] = getSpan(this, at, options)\n    const iterable = Node.nodes(this.value, {\n      ...options,\n      from,\n      to,\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\n    })\n\n    for (const entry of iterable) {\n      yield entry\n    }\n  }\n\n  /**\n   * Iterate through all of the positions in the document where a `Point` can be\n   * placed.\n   *\n   * By default it will move forward by individual offsets at a time,  but you\n   * can pass the `unit: 'character'` option to moved forward one character, word,\n   * or line at at time.\n   *\n   * Note: void nodes are treated as a single point, and iteration will not\n   * happen inside their content.\n   */\n\n  *positions(\n    this: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n    } = {}\n  ): Iterable<Point> {\n    const {\n      at = this.value.selection,\n      unit = 'offset',\n      reverse = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = this.getRange(at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let string = ''\n    let available = 0\n    let offset = 0\n    let distance: number | null = null\n    let isNewBlock = false\n\n    const advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string)\n        } else if (unit === 'word') {\n          distance = getWordDistance(string)\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length\n        } else {\n          distance = 1\n        }\n\n        string = string.slice(distance)\n      }\n\n      // Add or substract the offset.\n      offset = reverse ? offset - distance : offset + distance\n      // Subtract the distance traveled from the available text.\n      available = available - distance!\n      // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n      distance = available >= 0 ? null : 0 - available\n    }\n\n    for (const [node, path] of this.nodes({ at, reverse })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (this.isVoid(node)) {\n          yield this.getStart(path)\n          continue\n        }\n\n        if (this.isInline(node)) {\n          continue\n        }\n\n        if (this.hasInlines(node)) {\n          let e = Path.isAncestor(path, end.path) ? end : this.getEnd(path)\n          let s = Path.isAncestor(path, start.path)\n            ? start\n            : this.getStart(path)\n\n          const text = this.getText({ anchor: s, focus: e })\n          string = reverse ? reverseText(text) : text\n          isNewBlock = true\n        }\n      }\n\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n        available = node.text.length\n        offset = reverse ? available : 0\n\n        if (isFirst) {\n          available = reverse ? first.offset : available - first.offset\n          offset = first.offset\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset }\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break\n          } else {\n            advance()\n          }\n\n          // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n          if (available >= 0) {\n            yield { path, offset }\n          } else {\n            break\n          }\n        }\n\n        isNewBlock = false\n      }\n    }\n  }\n\n  /**\n   * Iterate through all of the text nodes in the editor.\n   */\n\n  *texts(\n    this: Editor,\n    options: {\n      at?: Location | Span\n      reverse?: boolean\n    } = {}\n  ): Iterable<TextEntry> {\n    const { at = this.value.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [from, to] = getSpan(this, at, options)\n\n    yield* Node.texts(this.value, {\n      ...options,\n      from,\n      to,\n      pass: ([n]) => Element.isElement(n) && this.isVoid(n),\n    })\n  }\n}\n\n/**\n * Get the from and to path span from a location.\n */\n\nconst getSpan = (\n  editor: Editor,\n  at: Location | Span,\n  options: {\n    reverse?: boolean\n  } = {}\n): Span => {\n  const { reverse = false } = options\n\n  if (Span.isSpan(at)) {\n    return at\n  }\n\n  const first = editor.getPath(at, { edge: 'start' })\n  const last = editor.getPath(at, { edge: 'end' })\n  const from = reverse ? last : first\n  const to = reverse ? first : last\n  return [from, to]\n}\n\n/**\n * Check if a node is a match.\n */\n\nconst isMatch = (editor: Editor, entry: NodeEntry, match: Match) => {\n  const [node, path] = entry\n\n  if (typeof match === 'function') {\n    return match(entry)\n  } else if (typeof match === 'number') {\n    return path.length === match\n  } else if (match === 'text') {\n    return Text.isText(node)\n  } else if (match === 'value') {\n    return Value.isValue(node)\n  } else if (match === 'inline') {\n    return (\n      (Element.isElement(node) && editor.isInline(node)) || Text.isText(node)\n    )\n  } else if (match === 'block') {\n    return (\n      Element.isElement(node) &&\n      !editor.isInline(node) &&\n      editor.hasInlines(node)\n    )\n  } else if (match === 'void') {\n    return Element.isElement(node) && editor.isVoid(node)\n  } else if (Path.isPath(match)) {\n    return Path.equals(path, match)\n  } else {\n    return Node.matches(node, match)\n  }\n}\n\nexport default LocationQueries\n","import { Editor, Path, Range } from '../..'\n\nclass RangeQueries {\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(this: Editor, range: Range): Range {\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const closestBlock = this.getMatch(end.path, 'block')\n    const blockPath = closestBlock ? closestBlock[1] : []\n    const first = this.getStart([])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of this.texts({ at: before, reverse: true })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  }\n}\n\nexport default RangeQueries\n","import { produce } from 'immer'\nimport { Operation, Value } from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  FLUSHING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from './utils'\nimport AnnotationCommands from './commands/annotation'\nimport TextCommands from './commands/text'\nimport NodeCommands from './commands/node'\nimport MarkCommands from './commands/mark'\nimport SelectionCommands from './commands/selection'\nimport GeneralCommands from './commands/general'\nimport ElementQueries from './queries/element'\nimport GeneralQueries from './queries/general'\nimport LocationQueries from './queries/location'\nimport RangeQueries from './queries/range'\n\n/**\n * The `Editor` class stores all the state of a Slate editor. It is extended by\n * plugins that wish to add their own methods that implement new behaviors.\n */\n\nclass Editor {\n  onChange: (value: Value, operations: Operation[]) => void\n  operations: Operation[]\n  value: Value\n\n  constructor(\n    props: {\n      onChange?(value: Value, operations: Operation[]): void\n      readOnly?: boolean\n      value?: Value\n    } = {}\n  ) {\n    const {\n      onChange = () => {},\n      value = produce(\n        { nodes: [], selection: null, annotations: {} },\n        () => {}\n      ),\n    } = props\n\n    this.onChange = onChange\n    this.operations = []\n    this.value = value\n\n    DIRTY_PATHS.set(this, [])\n    FLUSHING.set(this, false)\n    NORMALIZING.set(this, true)\n    PATH_REFS.set(this, new Set())\n    POINT_REFS.set(this, new Set())\n    RANGE_REFS.set(this, new Set())\n  }\n}\n\ninterface Editor\n  extends AnnotationCommands,\n    TextCommands,\n    NodeCommands,\n    MarkCommands,\n    SelectionCommands,\n    GeneralCommands,\n    ElementQueries,\n    GeneralQueries,\n    LocationQueries,\n    RangeQueries {}\n\nconst mixin = (Mixins: Array<new () => any>) => {\n  for (const Mixin of Mixins) {\n    for (const key of Object.getOwnPropertyNames(Mixin.prototype)) {\n      if (key !== 'constructor') {\n        Editor.prototype[key] = Mixin.prototype[key]\n      }\n    }\n  }\n}\n\nmixin([\n  AnnotationCommands,\n  TextCommands,\n  NodeCommands,\n  MarkCommands,\n  SelectionCommands,\n  GeneralCommands,\n  ElementQueries,\n  GeneralQueries,\n  LocationQueries,\n  RangeQueries,\n])\n\nexport { Editor }\n","import { Operation, Path, Editor } from '..'\nimport { PATH_REFS } from './utils'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nclass PathRef {\n  current: Path | null\n  private affinity: 'forward' | 'backward' | null\n  private editor: Editor\n\n  constructor(props: {\n    path: Path | null\n    affinity: 'forward' | 'backward' | null\n    editor: Editor\n  }) {\n    const { path, affinity, editor } = props\n    this.current = path\n    this.affinity = affinity\n    this.editor = editor\n    const pathRefs = PATH_REFS.get(editor)!\n    pathRefs.add(this)\n  }\n\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(op: Operation): void {\n    const { current, affinity } = this\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    this.current = path\n\n    if (path == null) {\n      this.unref()\n    }\n  }\n\n  /**\n   * Unreference the ref, allowing the editor to stop updating its value.\n   */\n\n  unref(): Path | null {\n    const { current, editor } = this\n    const pathRefs = PATH_REFS.get(editor)!\n    pathRefs.delete(this)\n    this.current = null\n    return current\n  }\n}\n\nexport { PathRef }\n","import { Operation, Point, Editor } from '..'\nimport { POINT_REFS } from './utils'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nclass PointRef {\n  current: Point | null\n  private affinity: 'forward' | 'backward' | null\n  private editor: Editor\n\n  constructor(props: {\n    point: Point | null\n    affinity: 'forward' | 'backward' | null\n    editor: Editor\n  }) {\n    const { point, affinity, editor } = props\n    this.current = point\n    this.affinity = affinity\n    this.editor = editor\n    const pointRefs = POINT_REFS.get(editor)!\n    pointRefs.add(this)\n  }\n\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(op: Operation): void {\n    const { current, affinity } = this\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    this.current = point\n\n    if (point == null) {\n      this.unref()\n    }\n  }\n\n  /**\n   * Unreference the ref, allowing the editor to stop updating its value.\n   */\n\n  unref(): Point | null {\n    const { current, editor } = this\n    const pointRefs = POINT_REFS.get(editor)!\n    pointRefs.delete(this)\n    this.current = null\n    return current\n  }\n}\n\nexport { PointRef }\n","import { Operation, Range, Editor } from '..'\nimport { RANGE_REFS } from './utils'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nclass RangeRef {\n  current: Range | null\n  private affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  private editor: Editor\n\n  constructor(props: {\n    range: Range | null\n    affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n    editor: Editor\n  }) {\n    const { range, affinity, editor } = props\n    this.current = range\n    this.affinity = affinity\n    this.editor = editor\n    const rangeRefs = RANGE_REFS.get(editor)!\n    rangeRefs.add(this)\n  }\n\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(op: Operation): void {\n    const { current, affinity } = this\n\n    if (current == null) {\n      return\n    }\n\n    const range = Range.transform(current, op, { affinity })\n    this.current = range\n\n    if (range == null) {\n      this.unref()\n    }\n  }\n\n  /**\n   * Unreference the ref, allowing the editor to stop updating its value.\n   */\n\n  unref(): Range | null {\n    const { current, editor } = this\n    const rangeRefs = RANGE_REFS.get(editor)!\n    rangeRefs.delete(this)\n    this.current = null\n    return current\n  }\n}\n\nexport { RangeRef }\n","import isPlainObject from 'is-plain-object'\nimport { Node, Path, Value } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's schema.\n */\n\ninterface Element {\n  nodes: Node[]\n  [key: string]: any\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\ntype ElementEntry = [Element, Path]\n\nnamespace Element {\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  export const isElement = (value: any): value is Element => {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.nodes) &&\n      !Value.isValue(value)\n    )\n  }\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  export const isElementList = (value: any): value is Element[] => {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Element.isElement(value[0]))\n    )\n  }\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: the is for checking custom properties, and it does not ensure that\n   * any children in the `nodes` property are equal.\n   */\n\n  export const matches = (\n    element: Element,\n    props: Partial<Element>\n  ): boolean => {\n    for (const key in props) {\n      if (key === 'nodes') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nexport { Element, ElementEntry }\n","import isPlainObject from 'is-plain-object'\nimport { Node } from '..'\n\n/**\n * The `Fragment` interface describes a tree of nodes that exist independent of\n * a Slate document.\n */\n\ninterface Fragment {\n  nodes: Node[]\n  [key: string]: any\n}\n\nnamespace Fragment {\n  /**\n   * Check if a value implements the `Fragment` interface.\n   */\n\n  export const isFragment = (value: any): value is Fragment => {\n    return isPlainObject(value) && Node.isNodeList(value.nodes)\n  }\n}\n\nexport { Fragment }\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\ntype Location = Path | Point | Range\n\nnamespace Location {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  export const isLocation = (value: any): value is Location => {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  }\n}\n\ntype Span = [Path, Path]\n\nnamespace Span {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  export const isSpan = (value: any): value is Span => {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  }\n}\n\nexport { Location, Span }\n","import isPlainObject from 'is-plain-object'\nimport { Path, Text } from '..'\n\n/**\n * `Mark` objects represent formatting that is applied to text in a Slate\n * document. They appear in leaf text nodes in the document, as well as in\n * annotations on the root value object.\n */\n\ninterface Mark {\n  [key: string]: any\n}\n\n/**\n * `MarkEntry` tuples are returned when iterating through the marks in a text\n * node. They include the index of the mark in the text node's marks array, as\n * well as the text node and its path in the root node.\n */\n\ntype MarkEntry = [Mark, number, Text, Path]\n\nnamespace Mark {\n  /**\n   * Check if a mark exists in a set of marks.\n   */\n\n  export const exists = (mark: Mark, marks: Mark[]): boolean => {\n    return !!marks.find(f => Mark.matches(f, mark))\n  }\n\n  /**\n   * Check if a value implements the `Mark` interface.\n   */\n\n  export const isMark = (value: any): value is Mark => {\n    return isPlainObject(value)\n  }\n\n  /**\n   * Check if a value is an array of `Mark` objects.\n   */\n\n  export const isMarkSet = (value: any): value is Mark[] => {\n    return Array.isArray(value) && (value.length === 0 || Mark.isMark(value[0]))\n  }\n\n  /**\n   * Check if a mark matches set of properties.\n   */\n\n  export const matches = (mark: Mark, props: Partial<Mark>): boolean => {\n    for (const key in props) {\n      if (mark[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nexport { Mark, MarkEntry }\n","import { produce } from 'immer'\nimport {\n  Element,\n  ElementEntry,\n  Fragment,\n  MarkEntry,\n  Path,\n  Range,\n  Text,\n  TextEntry,\n  Value,\n} from '..'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\ntype Node = Value | Element | Text\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\ntype Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\ntype Ancestor = Value | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\ntype NodeEntry = [Node, Path]\n\n/**\n * `DescendantEntry` objects are returned when iterating over the descendants in\n * a Slate document tree.\n */\n\ntype DescendantEntry = [Descendant, Path]\n\n/**\n * `AncestorEntry` objects are returned when iterating over the ancestors in a\n * Slate document tree.\n */\n\ntype AncestorEntry = [Ancestor, Path]\n\nnamespace Node {\n  export const matches = (node: Node, props: Partial<Node>): boolean => {\n    return (\n      (Value.isValue(node) && Value.matches(node, props)) ||\n      (Element.isElement(node) && Element.matches(node, props)) ||\n      (Text.isText(node) && Text.matches(node, props))\n    )\n  }\n\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  export const ancestor = (root: Node, path: Path): Ancestor => {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  }\n\n  /**\n   * Return an iterable of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  export function* ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<AncestorEntry> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: AncestorEntry = [n, p]\n      yield entry\n    }\n  }\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  export const child = (root: Node, index: number): Descendant => {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.nodes[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  }\n\n  /**\n   * Find the closest matching node entry starting from a specific path.\n   */\n\n  export const closest = (\n    root: Node,\n    path: Path,\n    predicate: (entry: NodeEntry) => boolean\n  ): NodeEntry | undefined => {\n    for (const entry of Node.levels(root, path, { reverse: true })) {\n      if (predicate(entry)) {\n        return entry\n      }\n    }\n  }\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  export const common = (root: Node, path: Path, another: Path): NodeEntry => {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  }\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  export const descendant = (root: Node, path: Path): Descendant => {\n    const node = Node.get(root, path)\n\n    if (Value.isValue(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to a value node instead: ${node}`\n      )\n    }\n\n    return node\n  }\n\n  /**\n   * Return an iterable of all the descendant node entries inside a root node.\n   */\n\n  export function* descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<DescendantEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Value`, but TypeScript doesn't know.\n        yield [node, path] as DescendantEntry\n      }\n    }\n  }\n\n  /**\n   * Return an iterable of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  export function* elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<ElementEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  }\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  export const first = (root: Node, path: Path): NodeEntry => {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.nodes.length === 0) {\n        break\n      } else {\n        n = n.nodes[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  }\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  export const fragment = (root: Node, range: Range): Fragment => {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return produce(root, r => {\n      const [start, end] = Range.edges(range)\n      const iterable = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of iterable) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.nodes.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      delete r.annotations\n      delete r.selection\n    })\n  }\n\n  /**\n   * Find the furthest matching node entry starting from a specific path.\n   */\n\n  export const furthest = (\n    root: Node,\n    path: Path,\n    predicate: (entry: NodeEntry) => boolean\n  ): NodeEntry | undefined => {\n    for (const entry of Node.levels(root, path)) {\n      if (predicate(entry)) {\n        return entry\n      }\n    }\n  }\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  export const get = (root: Node, path: Path): Node => {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.nodes[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.nodes[p]\n    }\n\n    return node\n  }\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  export const has = (root: Node, path: Path): boolean => {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.nodes[p]) {\n        return false\n      }\n\n      node = node.nodes[p]\n    }\n\n    return true\n  }\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  export const isNode = (value: any): value is Node => {\n    return (\n      Text.isText(value) || Element.isElement(value) || Value.isValue(value)\n    )\n  }\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  export const isNodeList = (value: any): value is Node[] => {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\n  }\n\n  /**\n   * Get the lash node entry in a root node from a path.\n   */\n\n  export const last = (root: Node, path: Path): NodeEntry => {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.nodes.length === 0) {\n        break\n      } else {\n        const i = n.nodes.length - 1\n        n = n.nodes[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  }\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  export const leaf = (root: Node, path: Path): Text => {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  }\n\n  /**\n   * Return an iterable of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest node in the\n   * tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  export function* levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  }\n\n  /**\n   * Return an iterable of all the marks in all of the text nodes in a root node.\n   */\n\n  export function* marks(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<MarkEntry> {\n    for (const [node, path] of Node.texts(root, options)) {\n      for (let i = 0; i < node.marks.length; i++) {\n        const mark = node.marks[i]\n        yield [mark, i, node, path]\n      }\n    }\n  }\n\n  /**\n   * Return an iterable of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  export function* nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't decsended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.nodes.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.nodes.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  }\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  export const parent = (root: Node, path: Path): Ancestor => {\n    const parentPath = Path.parent(path)\n    const parent = Node.get(root, parentPath)\n\n    if (Text.isText(parent)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return parent\n  }\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  export const text = (node: Node): string => {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.nodes.map(Node.text).join('')\n    }\n  }\n\n  /**\n   * Return an iterable of all leaf text nodes in a root node.\n   */\n\n  export function* texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<TextEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  }\n}\n\nexport { Ancestor, AncestorEntry, Descendant, DescendantEntry, Node, NodeEntry }\n","import { Mark, Node, Path, Range, Value } from '..'\nimport isPlainObject from 'is-plain-object'\n\ntype AddAnnotationOperation = {\n  type: 'add_annotation'\n  key: string\n  annotation: Range\n  [key: string]: any\n}\n\ntype AddMarkOperation = {\n  type: 'add_mark'\n  path: Path\n  mark: Mark\n  [key: string]: any\n}\n\ntype InsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n  [key: string]: any\n}\n\ntype InsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: any\n}\n\ntype MergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  target: number | null\n  properties: Partial<Node>\n  [key: string]: any\n}\n\ntype MoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n  [key: string]: any\n}\n\ntype RemoveAnnotationOperation = {\n  type: 'remove_annotation'\n  key: string\n  annotation: Range\n  [key: string]: any\n}\n\ntype RemoveMarkOperation = {\n  type: 'remove_mark'\n  path: Path\n  mark: Mark\n  [key: string]: any\n}\n\ntype RemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n  [key: string]: any\n}\n\ntype RemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: any\n}\n\ntype SetAnnotationOperation = {\n  type: 'set_annotation'\n  key: string\n  properties: Partial<Range>\n  newProperties: Partial<Range>\n  [key: string]: any\n}\n\ntype SetMarkOperation = {\n  type: 'set_mark'\n  path: Path\n  properties: Partial<Mark>\n  newProperties: Partial<Mark>\n  [key: string]: any\n}\n\ntype SetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n  [key: string]: any\n}\n\ntype SetSelectionOperation =\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: any\n      properties: Range\n      newProperties: null\n    }\n\ntype SetValueOperation = {\n  type: 'set_value'\n  properties: Partial<Value>\n  newProperties: Partial<Value>\n  [key: string]: any\n}\n\ntype SplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  target: number | null\n  properties: Partial<Node>\n  [key: string]: any\n}\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\ntype Operation =\n  | AnnotationOperation\n  | NodeOperation\n  | MarkOperation\n  | SelectionOperation\n  | TextOperation\n  | ValueOperation\n\ntype AnnotationOperation =\n  | AddAnnotationOperation\n  | RemoveAnnotationOperation\n  | SetAnnotationOperation\n\ntype NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\ntype MarkOperation = AddMarkOperation | RemoveMarkOperation | SetMarkOperation\n\ntype SelectionOperation = SetSelectionOperation\n\ntype TextOperation = InsertTextOperation | RemoveTextOperation\n\ntype ValueOperation = SetValueOperation\n\nnamespace Operation {\n  /**\n   * Check of a value is an `AnnotationOperation` object.\n   */\n\n  export const isAnnotationOperation = (\n    value: any\n  ): value is AnnotationOperation => {\n    return Operation.isOperation(value) && value.type.endsWith('_annotation')\n  }\n\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  export const isNodeOperation = (value: any): value is NodeOperation => {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  }\n\n  /**\n   * Check of a value is a `MarkOperation` object.\n   */\n\n  export const isMarkOperation = (value: any): value is MarkOperation => {\n    return Operation.isOperation(value) && value.type.endsWith('_mark')\n  }\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  export const isOperation = (value: any): value is Operation => {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'add_mark': {\n        return Path.isPath(value.path) && Mark.isMark(value.mark)\n      }\n\n      case 'add_annotation': {\n        return typeof value.key === 'string' && Range.isRange(value.annotation)\n      }\n\n      case 'insert_node': {\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      }\n\n      case 'insert_text': {\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      }\n\n      case 'merge_node': {\n        return (\n          typeof value.position === 'number' &&\n          (typeof value.target === 'number' || value.target === null) &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      }\n\n      case 'move_node': {\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      }\n\n      case 'remove_annotation': {\n        return typeof value.key === 'string' && Range.isRange(value.annotation)\n      }\n\n      case 'remove_mark': {\n        return Path.isPath(value.path) && Mark.isMark(value.mark)\n      }\n\n      case 'remove_node': {\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      }\n\n      case 'remove_text': {\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      }\n\n      case 'set_annotation': {\n        return (\n          typeof value.key === 'string' &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'set_mark': {\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'set_node': {\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'set_selection': {\n        return (\n          isPlainObject(value.properties) && isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'set_value': {\n        return (\n          isPlainObject(value.properties) && isPlainObject(value.newProperties)\n        )\n      }\n\n      case 'split_node': {\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          (typeof value.target === 'number' || value.target === null) &&\n          isPlainObject(value.properties)\n        )\n      }\n\n      default: {\n        return false\n      }\n    }\n  }\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  export const isOperationList = (value: any): value is Operation[] => {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Operation.isOperation(value[0]))\n    )\n  }\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  export const isSelectionOperation = (\n    value: any\n  ): value is SelectionOperation => {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  }\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  export const isTextOperation = (value: any): value is TextOperation => {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  }\n\n  /**\n   * Check of a value is a `ValueOperation` object.\n   */\n\n  export const isValueOperation = (value: any): value is ValueOperation => {\n    return Operation.isOperation(value) && value.type.endsWith('_value')\n  }\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  export const inverse = (op: Operation): Operation => {\n    switch (op.type) {\n      case 'add_annotation': {\n        return { ...op, type: 'remove_annotation' }\n      }\n\n      case 'add_mark': {\n        return { ...op, type: 'remove_mark' }\n      }\n\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // We need to get the original path here, but sometimes the `newPath`\n        // is a younger sibling of (or ends before) the original, and this\n        // accounts for it.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_annotation': {\n        return { ...op, type: 'add_annotation' }\n      }\n\n      case 'remove_mark': {\n        return { ...op, type: 'add_mark' }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_annotation':\n      case 'set_mark':\n      case 'set_node':\n      case 'set_value': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  }\n}\n\nexport {\n  AddMarkOperation,\n  AddAnnotationOperation,\n  InsertNodeOperation,\n  InsertTextOperation,\n  MergeNodeOperation,\n  MoveNodeOperation,\n  RemoveAnnotationOperation,\n  RemoveMarkOperation,\n  RemoveNodeOperation,\n  RemoveTextOperation,\n  SetAnnotationOperation,\n  SetMarkOperation,\n  SetNodeOperation,\n  SetSelectionOperation,\n  SetValueOperation,\n  SplitNodeOperation,\n  Operation,\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Value`\n * object, they can be relative to any `Node` object.\n */\n\ntype Path = number[]\n\nnamespace Path {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  export const ancestors = (\n    path: Path,\n    options: { reverse?: boolean } = {}\n  ): Path[] => {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  }\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  export const common = (path: Path, another: Path): Path => {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  }\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  export const compare = (path: Path, another: Path): -1 | 0 | 1 => {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  }\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  export const endsAfter = (path: Path, another: Path): boolean => {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  }\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  export const endsAt = (path: Path, another: Path): boolean => {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  }\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  export const endsBefore = (path: Path, another: Path): boolean => {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  }\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  export const equals = (path: Path, another: Path): boolean => {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  }\n\n  /**\n   * Check if a path is after another.\n   */\n\n  export const isAfter = (path: Path, another: Path): boolean => {\n    return Path.compare(path, another) === 1\n  }\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  export const isAncestor = (path: Path, another: Path): boolean => {\n    return path.length < another.length && Path.compare(path, another) === 0\n  }\n\n  /**\n   * Check if a path is before another.\n   */\n\n  export const isBefore = (path: Path, another: Path): boolean => {\n    return Path.compare(path, another) === -1\n  }\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  export const isChild = (path: Path, another: Path): boolean => {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  }\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  export const isCommon = (path: Path, another: Path): boolean => {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  }\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  export const isDescendant = (path: Path, another: Path): boolean => {\n    return path.length > another.length && Path.compare(path, another) === 0\n  }\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  export const isParent = (path: Path, another: Path): boolean => {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  }\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  export const isPath = (value: any): value is Path => {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  }\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  export const isSibling = (path: Path, another: Path): boolean => {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  }\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from deepest to shallowest. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  export const levels = (\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] => {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  }\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  export const next = (path: Path): Path => {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  }\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  export const parent = (path: Path): Path => {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  }\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  export const previous = (path: Path): Path => {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  }\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  export const relative = (path: Path, ancestor: Path): Path => {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  }\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  export const transform = (\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null => {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            let copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              const i = Math.min(onp.length, op.length) - 1\n              copy[i] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            if (\n              Path.endsBefore(onp, p) ||\n              Path.equals(onp, p) ||\n              Path.isAncestor(onp, p)\n            ) {\n              p[onp.length - 1] += 1\n            }\n          }\n\n          break\n        }\n      }\n    })\n  }\n}\n\nexport { Path }\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\ninterface Point {\n  path: Path\n  offset: number\n  [key: string]: any\n}\n\n/**\n * `PointKey` is either an \"anchor\" or \"focus\" point string.\n */\n\ntype PointKey = 'anchor' | 'focus'\n\nnamespace Point {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  export const compare = (point: Point, another: Point): -1 | 0 | 1 => {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  }\n\n  /**\n   * Check if a point is after another.\n   */\n\n  export const isAfter = (point: Point, another: Point): boolean => {\n    return Point.compare(point, another) === 1\n  }\n\n  /**\n   * Check if a point is before another.\n   */\n\n  export const isBefore = (point: Point, another: Point): boolean => {\n    return Point.compare(point, another) === -1\n  }\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  export const equals = (point: Point, another: Point): boolean => {\n    // PERF: We could compare to a result of `0` here, but it's slightly faster\n    // to first ensure the offsets are equal and to use `Path.equals`.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  }\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  export const isPoint = (value: any): value is Point => {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  }\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  export const transform = (\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null => {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  }\n}\n\nexport { Point, PointKey }\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { Operation, Path, Point } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\ninterface Range {\n  anchor: Point\n  focus: Point\n  [key: string]: any\n}\n\nnamespace Range {\n  export const start = (range: Range): Point => {\n    const [start] = Range.edges(range)\n    return start\n  }\n\n  export const end = (range: Range): Point => {\n    const [, end] = Range.edges(range)\n    return end\n  }\n\n  export const intersection = (range: Range, another: Range): Range | null => {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  }\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  export const equals = (range: Range, another: Range): boolean => {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  }\n\n  /**\n   * Check if a range exists in a list or map of ranges.\n   */\n\n  export const exists = (\n    range: Range,\n    target: Range[] | Record<string, Range>\n  ): boolean => {\n    if (Range.isRangeList(target)) {\n      return !!target.find(r => Range.equals(r, range))\n    }\n\n    if (Range.isRangeMap(target)) {\n      for (const key in target) {\n        if (Range.equals(range, target[key])) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  export const includes = (\n    range: Range,\n    target: Path | Point | Range\n  ): boolean => {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  }\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  export const isBackward = (range: Range): boolean => {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  }\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  export const isCollapsed = (range: Range): boolean => {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  }\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  export const isExpanded = (range: Range): boolean => {\n    return !isCollapsed(range)\n  }\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  export const isForward = (range: Range): boolean => {\n    return !isBackward(range)\n  }\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  export const isRange = (value: any): value is Range => {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  }\n\n  /**\n   * Check if a value is an array of `Range` objects.\n   */\n\n  export const isRangeList = (value: any): value is Range[] => {\n    return (\n      Array.isArray(value) && (value.length === 0 || Range.isRange(value[0]))\n    )\n  }\n\n  /**\n   * Check if a value is a map of `Range` objects.\n   */\n\n  export const isRangeMap = (value: any): value is Record<string, Range> => {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    for (const key in value) {\n      return Range.isRange(value[key])\n    }\n\n    return true\n  }\n\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  export const edges = (\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] => {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  }\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  export const transform = (\n    range: Range,\n    op: Operation,\n    options: { affinity: 'forward' | 'backward' | 'outward' | 'inward' | null }\n  ): Range | null => {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  }\n}\n\nexport { Range }\n","import isPlainObject from 'is-plain-object'\nimport { Mark, Path } from '..'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting marks. They are always leaf nodes in\n * the document tree as they cannot contain any children.\n */\n\ninterface Text {\n  text: string\n  marks: Mark[]\n  [key: string]: any\n}\n\n/**\n * `TextEntry` objects refer to an `Text` and the `Path` where it can be\n * found inside a root node.\n */\n\ntype TextEntry = [Text, Path]\n\nnamespace Text {\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  export const isText = (value: any): value is Text => {\n    return (\n      isPlainObject(value) &&\n      typeof value.text === 'string' &&\n      Array.isArray(value.marks)\n    )\n  }\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  export const isTextList = (value: any): value is Text[] => {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\n  }\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal. However, if `marks` are passed it\n   * will ensure that the set of marks is exactly equal.\n   */\n\n  export const matches = (text: Text, props: Partial<Text>): boolean => {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (key === 'marks' && props.marks != null) {\n        const existing = text.marks\n        const { marks } = props\n\n        // PERF: If the lengths aren't the same, we know it's not a match.\n        if (existing.length !== marks.length) {\n          return false\n        }\n\n        for (const m of existing) {\n          if (!Mark.exists(m, marks)) {\n            return false\n          }\n        }\n\n        for (const m of marks) {\n          if (!Mark.exists(m, existing)) {\n            return false\n          }\n        }\n\n        continue\n      }\n\n      if (text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\nexport { Text, TextEntry }\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport {\n  Element,\n  Mark,\n  Node,\n  Operation,\n  Path,\n  Point,\n  PointKey,\n  Range,\n  Descendant,\n  Text,\n} from '..'\n\n/**\n * `Value` objects hold all of the state in a Slate editor, including all of the\n * nodes in the document and the user's currently selected range of text.\n */\n\ninterface Value extends Element {\n  selection: Range | null\n  annotations: Record<string, Range>\n  [key: string]: any\n}\n\n/**\n * `ValueEntry` objects refer to an `Value` and the `Path` where it can be\n * found inside a root node.\n */\n\ntype ValueEntry = [Value, Path]\n\n/**\n * `AnnotationEntry` objects are returned when iterating over annotations\n * in the top-level value.\n */\n\ntype AnnotationEntry = [Range, string]\n\n/**\n * `AnnotationPointEntry` objects are returned when iterating over `Point`\n * objects that belong to an annotation.\n */\n\ntype AnnotationPointEntry = [Point, PointKey, Range, string]\n\n/**\n * `SelectionPointEntry` objects are returned when iterating over `Point`\n * objects that belong to a selection.\n */\n\ntype SelectionPointEntry = [Point, PointKey, Range]\n\nnamespace Value {\n  /**\n   * Check if a value implements the `Value` interface.\n   */\n\n  export const isValue = (value: any): value is Value => {\n    return (\n      isPlainObject(value) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.nodes) &&\n      Range.isRangeMap(value.annotations)\n    )\n  }\n\n  /**\n   * Check if a value matches a set of properties.\n   *\n   * Note: the is for checking custom properties, and it does not ensure that\n   * any children in the `nodes` property are equal.\n   */\n\n  export const matches = (value: Value, props: Partial<Value>): boolean => {\n    for (const key in props) {\n      if (key === 'annotations' || key === 'nodes' || key === 'selection') {\n        continue\n      }\n\n      if (value[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Iterate through all of the point objects in a value.\n   */\n\n  export function* points(\n    value: Value\n  ): Iterable<SelectionPointEntry | AnnotationPointEntry> {\n    const { selection, annotations } = value\n\n    if (selection != null) {\n      yield [selection.anchor, 'anchor', selection]\n      yield [selection.focus, 'focus', selection]\n    }\n\n    for (const key in annotations) {\n      const annotation = annotations[key]\n      yield [annotation.anchor, 'anchor', annotation, key]\n      yield [annotation.focus, 'focus', annotation, key]\n    }\n  }\n\n  /**\n   * Transform a value by an operation.\n   */\n\n  export const transform = (value: Value, op: Operation): Value => {\n    return produce(value, v => {\n      switch (op.type) {\n        case 'add_annotation': {\n          const { annotation, key } = op\n          v.annotations[key] = annotation\n          break\n        }\n\n        case 'add_mark': {\n          const { path, mark } = op\n          const node = Node.leaf(v, path)\n\n          if (!Mark.exists(mark, node.marks)) {\n            node.marks.push(mark)\n          }\n\n          break\n        }\n\n        case 'insert_node': {\n          const { path, node } = op\n          const parent = Node.parent(v, path)\n          const index = path[path.length - 1]\n          parent.nodes.splice(index, 0, node)\n\n          for (const [point, key, range] of Value.points(v)) {\n            range[key] = Point.transform(point, op)!\n          }\n\n          break\n        }\n\n        case 'insert_text': {\n          const { path, offset, text } = op\n          const node = Node.leaf(v, path)\n          const before = node.text.slice(0, offset)\n          const after = node.text.slice(offset)\n          node.text = before + text + after\n\n          for (const [point, key, range] of Value.points(v)) {\n            range[key] = Point.transform(point, op)!\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path } = op\n          const node = Node.get(v, path)\n          const prevPath = Path.previous(path)\n          const prev = Node.get(v, prevPath)\n          const parent = Node.parent(v, path)\n          const index = path[path.length - 1]\n\n          if (Text.isText(node) && Text.isText(prev)) {\n            prev.text += node.text\n          } else if (!Text.isText(node) && !Text.isText(prev)) {\n            prev.nodes.push(...node.nodes)\n          } else {\n            throw new Error(\n              `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n            )\n          }\n\n          parent.nodes.splice(index, 1)\n\n          for (const [point, key, range] of Value.points(v)) {\n            range[key] = Point.transform(point, op)!\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path, newPath } = op\n\n          if (Path.isAncestor(path, newPath)) {\n            throw new Error(\n              `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n            )\n          }\n\n          const node = Node.get(v, path)\n          const parent = Node.parent(v, path)\n          const index = path[path.length - 1]\n\n          // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n          parent.nodes.splice(index, 1)\n          const truePath = Path.transform(path, op)!\n          const newParent = Node.get(v, Path.parent(truePath))\n          const newIndex = truePath[truePath.length - 1]\n\n          newParent.nodes.splice(newIndex, 0, node)\n\n          for (const [point, key, range] of Value.points(v)) {\n            range[key] = Point.transform(point, op)!\n          }\n\n          break\n        }\n\n        case 'remove_annotation': {\n          const { key } = op\n          delete v.annotations[key]\n          break\n        }\n\n        case 'remove_mark': {\n          const { path, mark } = op\n          const node = Node.leaf(v, path)\n\n          for (let i = 0; i < node.marks.length; i++) {\n            if (Mark.matches(node.marks[i], mark)) {\n              node.marks.splice(i, 1)\n              break\n            }\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path } = op\n          const index = path[path.length - 1]\n          const parent = Node.parent(v, path)\n          const [, prev] = Node.texts(v, { from: path, reverse: true })\n          const [, next] = Node.texts(v, { from: path })\n          parent.nodes.splice(index, 1)\n\n          // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n          for (const [point, k, range, key] of Value.points(v)) {\n            const result = Point.transform(point, op)\n\n            if (result != null) {\n              range[k] = result\n            } else if (prev) {\n              const [prevNode, prevPath] = prev\n              point.path = prevPath\n              point.offset = prevNode.text.length\n            } else if (next) {\n              const [, nextPath] = next\n              const newNextPath = Path.transform(nextPath, op)!\n              point.path = newNextPath\n              point.offset = 0\n            } else if (key != null) {\n              delete v.annotations[key]\n            } else {\n              v.selection = null\n            }\n          }\n\n          break\n        }\n\n        case 'remove_text': {\n          const { path, offset, text } = op\n          const node = Node.leaf(v, path)\n          const before = node.text.slice(0, offset)\n          const after = node.text.slice(offset + text.length)\n          node.text = before + after\n\n          for (const [point, key, range] of Value.points(v)) {\n            range[key] = Point.transform(point, op)!\n          }\n\n          break\n        }\n\n        case 'set_annotation': {\n          const { key, newProperties } = op\n          const annotation = v.annotations[key]\n          Object.assign(annotation, newProperties)\n          break\n        }\n\n        case 'set_mark': {\n          const { path, properties, newProperties } = op\n          const node = Node.leaf(v, path)\n\n          for (const mark of node.marks) {\n            if (Mark.matches(mark, properties)) {\n              Object.assign(mark, newProperties)\n              break\n            }\n          }\n\n          break\n        }\n\n        case 'set_node': {\n          const { path, newProperties } = op\n          const node = Node.get(v, path)\n          Object.assign(node, newProperties)\n          break\n        }\n\n        case 'set_selection': {\n          const { newProperties } = op\n\n          if (newProperties == null) {\n            v.selection = newProperties\n          } else if (v.selection == null) {\n            if (!Range.isRange(newProperties)) {\n              throw new Error(\n                `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                  newProperties\n                )} when there is no current selection.`\n              )\n            }\n\n            v.selection = newProperties\n          } else {\n            Object.assign(v.selection, newProperties)\n          }\n\n          break\n        }\n\n        case 'set_value': {\n          const { newProperties } = op\n          Object.assign(v, newProperties)\n          break\n        }\n\n        case 'split_node': {\n          const { path, position, properties } = op\n\n          if (path.length === 0) {\n            throw new Error(\n              `Cannot apply a \"split_node\" operation at path [${path}] because the top-level value cannot be split.`\n            )\n          }\n\n          const node = Node.get(v, path)\n          const parent = Node.parent(v, path)\n          const index = path[path.length - 1]\n          let newNode: Descendant\n\n          if (Text.isText(node)) {\n            const before = node.text.slice(0, position)\n            const after = node.text.slice(position)\n            node.text = before\n            newNode = { ...node, ...(properties as Partial<Text>), text: after }\n          } else {\n            const before = node.nodes.slice(0, position)\n            const after = node.nodes.slice(position)\n            node.nodes = before\n            newNode = {\n              ...node,\n              ...(properties as Partial<Element>),\n              nodes: after,\n            }\n          }\n\n          parent.nodes.splice(index + 1, 0, newNode)\n\n          for (const [point, key, range] of Value.points(v)) {\n            range[key] = Point.transform(point, op)!\n          }\n\n          break\n        }\n      }\n    })\n  }\n}\n\nexport {\n  Value,\n  ValueEntry,\n  AnnotationEntry,\n  AnnotationPointEntry,\n  SelectionPointEntry,\n}\n"],"names":["DIRTY_PATHS","WeakMap","NORMALIZING","FLUSHING","PATH_REFS","POINT_REFS","RANGE_REFS","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","isWordCharacter","char","remaining","test","next","charAt","length","getCharacterDistance","slice","rest","text","code","charCodeAt","isSurrogate","getWordDistance","i","started","l","AnnotationCommands","key","annotation","apply","type","annotations","value","Error","props","newProps","prevProps","k","isPoint","Point","equals","Object","keys","properties","newProperties","DeletingCommands","options","withoutNormalizing","reverse","unit","distance","at","selection","hanging","Range","isRange","isCollapsed","anchor","furthestVoid","getMatch","path","voidPath","opts","target","getBefore","getStart","getAfter","getEnd","focus","Path","isPath","removeNodes","unhangRange","edges","start","end","getAncestor","ancestor","isSingleText","startVoid","endVoid","block","before","isAncestor","after","matches","match","n","p","Element","isElement","isVoid","isCommon","pathRefs","Array","from","createPathRef","startRef","createPointRef","endRef","point","current","getLeaf","node","offset","pathRef","unref","isBlockAncestor","Value","isValue","isInline","mergeNodes","select","fragment","isSelection","pointRef","splitNodes","always","insertPath","insertNodes","nodes","afterClosest","beforeClosest","afterPath","beforePath","startPath","texts","NodeCommands","Node","isNode","Text","isText","atMatch","matchPath","isAtEnd","isEnd","parentPath","parent","index","concat","getNode","moveNodes","to","prev","getPrevious","prevNode","prevPath","newPath","commonPath","common","isPreviousSibling","isSibling","emptyAncestor","furthest","isDescendant","emptyRef","position","marks","JSON","stringify","isEmpty","toRef","targets","child","shouldHaveInlines","isLast","depths","height","deleteRange","getPoint","beforeRef","affinity","highest","voidMatch","nudge","voidNode","siblingHeight","afterRef","depth","highestPath","lowestPath","levels","split","isEdge","range","getRange","intersection","liftNodes","element","rangeRef","createRangeRef","roots","rootPath","a","first","last","firstPath","lastPath","wrapperPath","wrapper","editor","MarkCommands","splitLocation","set","mark","Mark","exists","push","existing","getActiveMarks","every","m","removeMarks","addMarks","SelectionCommands","edge","isBackward","setSelection","newPoint","assign","oldProps","GeneralCommands","op","transform","operations","get","ref","pathCache","dirtyPaths","add","join","getDirtyPaths","normalize","Promise","resolve","then","flush","onChange","force","allPaths","max","pop","normalizeNodes","fn","descendants","ancestors","previousPath","previous","oldAncestors","newAncestors","nextPath","ElementQueries","some","GeneralQueries","PathRef","PointRef","RangeRef","undefined","require$$0","LocationQueries","includes","getSpan","elements","pass","union","splice","d","positions","getParent","getPath","ancestorPath","leaf","entry","isMatch","getLast","span","getFirst","t","has","isStart","compare","iterable","string","available","isNewBlock","advance","hasInlines","e","s","getText","reverseText","isFirst","Span","isSpan","RangeQueries","closestBlock","blockPath","skip","isBefore","Editor","produce","Set","mixin","Mixins","Mixin","getOwnPropertyNames","prototype","TextCommands","pointRefs","rangeRefs","isPlainObject","isNodeList","isArray","Fragment","Location","find","f","isMark","root","c","predicate","another","r","visited","isAfter","nextIndex","map","Operation","isOperation","endsWith","inversePath","inverseNewPath","paths","av","bv","min","Math","as","bs","al","bl","list","operation","endsBefore","onp","copy","result","s1","e1","s2","e2","isRangeList","isRangeMap","rs","re","ts","te","isAfterStart","isBeforeEnd","affinityAnchor","affinityFocus","isForward","points","v","truePath","newParent","newIndex","newNextPath","newNode"],"mappings":"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"}